#include "pg.h"
#include <iostream>
#include <list>

/*
 * Iterative implementation of Tarjan's SCC algorithm.
 *
 * Rather than simply assigning the number generated by the algorithm to each SCC,
 * we assign consecutive numbers to SCCs to aid the compression process.
 */
void tarjan_iterative(std::vector<pg::Vertex>& vertices, std::vector<size_t>& scc)
{
	size_t unused = 1, lastscc = 0;
	std::vector<size_t> low;
	std::list<size_t> stack;
	std::list<size_t> sccstack;
	low.resize(vertices.size(), 0);
	for (size_t i = 0; i < vertices.size(); ++i)
	{
		if (scc[i] == 0)
			stack.push_back(i);
		while (not stack.empty())
		{
			size_t vi = stack.front();
			pg::Vertex& v = vertices[vi];

			if (low[vi] == 0)
			{
				scc[vi] = unused;
				low[vi] = unused++;
				for (pg::VertexSet::iterator w = v.out.begin(); w != v.out.end(); ++w)
				{
					if (low[*w] == 0 and scc[*w] == 0 and vertices[*w].label == v.label)
						stack.push_front(*w);
				}
			}
			else
			{
				for (pg::VertexSet::iterator w = v.out.begin(); w != v.out.end(); ++w)
				{
					if (low[*w] != 0 and vertices[*w].label == v.label)
						low[vi] = low[vi] < low[*w] ? low[vi] : low[*w];
				}
				if (low[vi] == scc[vi])
				{
					size_t tos, scc_id = lastscc++;
					sccstack.push_back(vi);
					do
					{
						tos = sccstack.front();
						low[tos] = 0;
						scc[tos] = scc_id;
						sccstack.pop_front();
					}
					while (not sccstack.empty());
				}
				else
					sccstack.push_back(stack.front());
				stack.pop_front();
			}
		}
	}
}

void collapse(std::vector<pg::Vertex>& vertices, std::vector<size_t>& sccs)
{
	pg::VertexSet temp;
	for (size_t i = 0; i < sccs.size(); ++i)
	{
		temp.clear();
		for (pg::VertexSet::iterator v = vertices[i].out.begin(); v != vertices[i].out.end(); ++v)
			temp.insert(sccs[*v]);
		vertices[i].out.swap(temp);
		temp.clear();
		for (pg::VertexSet::iterator v = vertices[i].in.begin(); v != vertices[i].in.end(); ++v)
			temp.insert(sccs[*v]);
		vertices[i].in.swap(temp);
	}
	for (size_t i = 0; i < sccs.size(); ++i)
	{
		size_t scc = sccs[i];
		while (sccs[scc] != scc)
		{
			pg::Vertex temp = vertices[i];
			sccs[i] = sccs[scc];
			sccs[scc] = scc;
			vertices[i] = vertices[scc];
			vertices[scc] = temp;
			scc = sccs[i];
		}
		if (i != scc)
		{
			vertices[scc].out.insert(vertices[i].out.begin(), vertices[i].out.end());
			vertices[scc].in.insert(vertices[i].in.begin(), vertices[i].in.end());
		}
	}
	size_t last = 0;
	for (size_t i = 0; i < sccs.size(); ++i)
	{
		if (sccs[i] == i)
		{
			vertices[last++] = vertices[i];
		}
	}
	vertices.resize(last);
}

namespace pg {

void ParityGame::collapse_sccs()
{
	std::vector<size_t> scc;
	scc.resize(m_vertices.size());
	tarjan_iterative(m_vertices, scc);
	collapse(m_vertices, scc);
}

}
